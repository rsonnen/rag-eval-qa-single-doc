<h1 id="using-csrf">How to use Django's CSRF protection</h1>
<p>To take advantage of CSRF protection in your views, follow these steps:</p>
<ol>
<li><p>The CSRF middleware is activated by default in the <code class="interpreted-text" role="setting">MIDDLEWARE</code> setting. If you override that setting, remember that <code>'django.middleware.csrf.CsrfViewMiddleware'</code> should come before any view middleware that assume that CSRF attacks have been dealt with.</p>
<p>If you disabled it, which is not recommended, you can use <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_protect</code> on particular views you want to protect (see below).</p></li>
<li><p>In any template that uses a POST form, use the <code class="interpreted-text" role="ttag">csrf_token</code> tag inside the <code>&lt;form&gt;</code> element if the form is for an internal URL, e.g.:</p>
<pre class="html+django"><code>&lt;form method=&quot;post&quot;&gt;{% csrf_token %}</code></pre>
<p>This should not be done for POST forms that target external URLs, since that would cause the CSRF token to be leaked, leading to a vulnerability.</p></li>
<li><p>In the corresponding view functions, ensure that <code class="interpreted-text" role="class">~django.template.RequestContext</code> is used to render the response so that <code>{% csrf_token %}</code> will work properly. If you're using the <code class="interpreted-text" role="func">~django.shortcuts.render</code> function, generic views, or contrib apps, you are covered already since these all use <code>RequestContext</code>.</p></li>
</ol>
<h2 id="csrf-ajax">Using CSRF protection with AJAX</h2>
<p>While the above method can be used for AJAX POST requests, it has some inconveniences: you have to remember to pass the CSRF token in as POST data with every POST request. For this reason, there is an alternative method: on each XMLHttpRequest, set a custom <code>X-CSRFToken</code> header (as specified by the <code class="interpreted-text" role="setting">CSRF_HEADER_NAME</code> setting) to the value of the CSRF token. This is often easier because many JavaScript frameworks provide hooks that allow headers to be set on every request.</p>
<p>First, you must get the CSRF token. How to do that depends on whether or not the <code class="interpreted-text" role="setting">CSRF_USE_SESSIONS</code> and <code class="interpreted-text" role="setting">CSRF_COOKIE_HTTPONLY</code> settings are enabled.</p>
<h3 id="acquiring-csrf-token-from-cookie">Acquiring the token if <code class="interpreted-text" role="setting">CSRF_USE_SESSIONS</code> and <code class="interpreted-text" role="setting">CSRF_COOKIE_HTTPONLY</code> are <code>False</code></h3>
<p>The recommended source for the token is the <code>csrftoken</code> cookie, which will be set if you've enabled CSRF protection for your views as outlined above.</p>
<p>The CSRF token cookie is named <code>csrftoken</code> by default, but you can control the cookie name via the <code class="interpreted-text" role="setting">CSRF_COOKIE_NAME</code> setting.</p>
<p>You can acquire the token like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getCookie</span>(name) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cookieValue <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="bu">document</span><span class="op">.</span><span class="at">cookie</span> <span class="op">&amp;&amp;</span> <span class="bu">document</span><span class="op">.</span><span class="at">cookie</span> <span class="op">!==</span> <span class="st">&#39;&#39;</span>) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> cookies <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="at">cookie</span><span class="op">.</span><span class="fu">split</span>(<span class="st">&#39;;&#39;</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> cookies<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">const</span> cookie <span class="op">=</span> cookies[i]<span class="op">.</span><span class="fu">trim</span>()<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Does this cookie string begin with the name we want?</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (cookie<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> name<span class="op">.</span><span class="at">length</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">===</span> (name <span class="op">+</span> <span class="st">&#39;=&#39;</span>)) {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                cookieValue <span class="op">=</span> <span class="pp">decodeURIComponent</span>(cookie<span class="op">.</span><span class="fu">substring</span>(name<span class="op">.</span><span class="at">length</span> <span class="op">+</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cookieValue<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> csrftoken <span class="op">=</span> <span class="fu">getCookie</span>(<span class="st">&#39;csrftoken&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>The above code could be simplified by using the <a href="https://github.com/js-cookie/js-cookie/">JavaScript Cookie library</a> to replace <code>getCookie</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> csrftoken <span class="op">=</span> Cookies<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;csrftoken&#39;</span>)<span class="op">;</span></span></code></pre></div>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The CSRF token is also present in the DOM in a masked form, but only if explicitly included using <code class="interpreted-text" role="ttag">csrf_token</code> in a template. The cookie contains the canonical, unmasked token. The <code class="interpreted-text" role="class">~django.middleware.csrf.CsrfViewMiddleware</code> will accept either. However, in order to protect against <a href="https://www.breachattack.com/">BREACH</a> attacks, it's recommended to use a masked token.</p>
</div>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>If your view is not rendering a template containing the <code class="interpreted-text" role="ttag">csrf_token</code> template tag, Django might not set the CSRF token cookie. This is common in cases where forms are dynamically added to the page. To address this case, Django provides a view decorator which forces setting of the cookie: <code class="interpreted-text" role="func">~django.views.decorators.csrf.ensure_csrf_cookie</code>.</p>
</div>
<h3 id="acquiring-csrf-token-from-html">Acquiring the token if <code class="interpreted-text" role="setting">CSRF_USE_SESSIONS</code> or <code class="interpreted-text" role="setting">CSRF_COOKIE_HTTPONLY</code> is <code>True</code></h3>
<p>If you activate <code class="interpreted-text" role="setting">CSRF_USE_SESSIONS</code> or <code class="interpreted-text" role="setting">CSRF_COOKIE_HTTPONLY</code>, you must include the CSRF token in your HTML and read the token from the DOM with JavaScript:</p>
<pre class="html+django"><code>{% csrf_token %}
&lt;script&gt;
const csrftoken = document.querySelector(&#39;[name=csrfmiddlewaretoken]&#39;).value;
&lt;/script&gt;</code></pre>
<h3 id="setting-the-token-on-the-ajax-request">Setting the token on the AJAX request</h3>
<p>Finally, you'll need to set the header on your AJAX request. Using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch()</a> API:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> request <span class="op">=</span> <span class="kw">new</span> <span class="fu">Request</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* URL */</span><span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">method</span><span class="op">:</span> <span class="st">&#39;POST&#39;</span><span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">headers</span><span class="op">:</span> {<span class="st">&#39;X-CSRFToken&#39;</span><span class="op">:</span> csrftoken}<span class="op">,</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;same-origin&#39;</span> <span class="co">// Do not send CSRF token to another domain.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(request)<span class="op">.</span><span class="fu">then</span>(<span class="kw">function</span>(response) {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<h2 id="using-csrf-protection-in-jinja2-templates">Using CSRF protection in Jinja2 templates</h2>
<p>Django's <code class="interpreted-text" role="class">~django.template.backends.jinja2.Jinja2</code> template backend adds <code>{{ csrf_input }}</code> to the context of all templates which is equivalent to <code>{% csrf_token %}</code> in the Django template language. For example:</p>
<pre class="html+jinja"><code>&lt;form method=&quot;post&quot;&gt;{{ csrf_input }}</code></pre>
<h2 id="using-the-decorator-method">Using the decorator method</h2>
<p>Rather than adding <code>CsrfViewMiddleware</code> as a blanket protection, you can use the <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_protect</code> decorator, which has exactly the same functionality, on particular views that need the protection. It must be used <strong>both</strong> on views that insert the CSRF token in the output, and on those that accept the POST form data. (These are often the same view function, but not always).</p>
<p>Use of the decorator by itself is <strong>not recommended</strong>, since if you forget to use it, you will have a security hole. The 'belt and braces' strategy of using both is fine, and will incur minimal overhead.</p>
<h2 id="csrf-rejected-requests">Handling rejected requests</h2>
<p>By default, a '403 Forbidden' response is sent to the user if an incoming request fails the checks performed by <code>CsrfViewMiddleware</code>. This should usually only be seen when there is a genuine Cross Site Request Forgery, or when, due to a programming error, the CSRF token has not been included with a POST form.</p>
<p>The error page, however, is not very friendly, so you may want to provide your own view for handling this condition. To do this, set the <code class="interpreted-text" role="setting">CSRF_FAILURE_VIEW</code> setting.</p>
<p>CSRF failures are logged as warnings to the <code class="interpreted-text" role="ref">django.security.csrf
&lt;django-security-logger&gt;</code> logger.</p>
<h2 id="using-csrf-protection-with-caching">Using CSRF protection with caching</h2>
<p>If the <code class="interpreted-text" role="ttag">csrf_token</code> template tag is used by a template (or the <code>get_token</code> function is called some other way), <code>CsrfViewMiddleware</code> will add a cookie and a <code>Vary: Cookie</code> header to the response. This means that the middleware will play well with the cache middleware if it is used as instructed (<code>UpdateCacheMiddleware</code> goes before all other middleware).</p>
<p>However, if you use cache decorators on individual views, the CSRF middleware will not yet have been able to set the Vary header or the CSRF cookie, and the response will be cached without either one. In this case, on any views that will require a CSRF token to be inserted you should use the <code class="interpreted-text" role="func">django.views.decorators.csrf.csrf_protect</code> decorator first:</p>
<pre><code>from django.views.decorators.cache import cache_page
from django.views.decorators.csrf import csrf_protect


@cache_page(60 * 15)
@csrf_protect
def my_view(request): ...</code></pre>
<p>If you are using class-based views, you can refer to <code class="interpreted-text" role="ref">Decorating
class-based views&lt;decorating-class-based-views&gt;</code>.</p>
<h2 id="testing-and-csrf-protection">Testing and CSRF protection</h2>
<p>The <code>CsrfViewMiddleware</code> will usually be a big hindrance to testing view functions, due to the need for the CSRF token which must be sent with every POST request. For this reason, Django's HTTP client for tests has been modified to set a flag on requests which relaxes the middleware and the <code>csrf_protect</code> decorator so that they no longer rejects requests. In every other respect (e.g. sending cookies etc.), they behave the same.</p>
<p>If, for some reason, you <em>want</em> the test client to perform CSRF checks, you can create an instance of the test client that enforces CSRF checks:</p>
<pre class="pycon"><code>&gt;&gt;&gt; from django.test import Client
&gt;&gt;&gt; csrf_client = Client(enforce_csrf_checks=True)</code></pre>
<h2 id="edge-cases">Edge cases</h2>
<p>Certain views can have unusual requirements that mean they don't fit the normal pattern envisaged here. A number of utilities can be useful in these situations. The scenarios they might be needed in are described in the following section.</p>
<h3 id="disabling-csrf-protection-for-just-a-few-views">Disabling CSRF protection for just a few views</h3>
<p>Most views requires CSRF protection, but a few do not.</p>
<p>Solution: rather than disabling the middleware and applying <code>csrf_protect</code> to all the views that need it, enable the middleware and use <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_exempt</code>.</p>
<h3 id="setting-the-token-when-csrfviewmiddleware.process_view-is-not-used">Setting the token when <code>CsrfViewMiddleware.process_view()</code> is not used</h3>
<p>There are cases when <code>CsrfViewMiddleware.process_view</code> may not have run before your view is run - 404 and 500 handlers, for example - but you still need the CSRF token in a form.</p>
<p>Solution: use <code class="interpreted-text" role="func">~django.views.decorators.csrf.requires_csrf_token</code></p>
<h3 id="including-the-csrf-token-in-an-unprotected-view">Including the CSRF token in an unprotected view</h3>
<p>There may be some views that are unprotected and have been exempted by <code>csrf_exempt</code>, but still need to include the CSRF token.</p>
<p>Solution: use <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_exempt</code> followed by <code class="interpreted-text" role="func">~django.views.decorators.csrf.requires_csrf_token</code>. (i.e. <code>requires_csrf_token</code> should be the innermost decorator).</p>
<h3 id="protecting-a-view-for-only-one-path">Protecting a view for only one path</h3>
<p>A view needs CSRF protection under one set of conditions only, and mustn't have it for the rest of the time.</p>
<p>Solution: use <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_exempt</code> for the whole view function, and <code class="interpreted-text" role="func">~django.views.decorators.csrf.csrf_protect</code> for the path within it that needs protection. Example:</p>
<pre><code>from django.views.decorators.csrf import csrf_exempt, csrf_protect


@csrf_exempt
def my_view(request):
    @csrf_protect
    def protected_path(request):
        do_something()

    if some_condition():
        return protected_path(request)
    else:
        do_something_else()</code></pre>
<h3 id="protecting-a-page-that-uses-ajax-without-an-html-form">Protecting a page that uses AJAX without an HTML form</h3>
<p>A page makes a POST request via AJAX, and the page does not have an HTML form with a <code class="interpreted-text" role="ttag">csrf_token</code> that would cause the required CSRF cookie to be sent.</p>
<p>Solution: use <code class="interpreted-text" role="func">~django.views.decorators.csrf.ensure_csrf_cookie</code> on the view that sends the page.</p>
<h2 id="csrf-protection-in-reusable-applications">CSRF protection in reusable applications</h2>
<p>Because it is possible for the developer to turn off the <code>CsrfViewMiddleware</code>, all relevant views in contrib apps use the <code>csrf_protect</code> decorator to ensure the security of these applications against CSRF. It is recommended that the developers of other reusable apps that want the same guarantees also use the <code>csrf_protect</code> decorator on their views.</p>
